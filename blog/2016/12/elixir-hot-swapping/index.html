<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-05-18 Thu 16:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Elixir/Erlang Hot Swapping Code</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="kb" />
<meta name="description" content="Hot code reloading with Elixir and Erlang"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta charset="utf-8">

<meta name="author" content="Kenny Ballou">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<title>~kb</title>

<link rel="canonical" href="/" />
<link href="/index.xml" rel="alternate" type="application/rss+xml"
      title="~kb/blog" />

<link rel="stylesheet" href="/css/simple.css" />
<link rel="stylesheet" href="/css/simple.add.css" />
<link rel="stylesheet" href="/css/katex.css" />
<link rel="stylesheet" href="/css/fa-all.css" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<script defer type="text/javascript" src="/js/katex.js"></script>
<script defer type="text/javascript" src="/js/katex-render.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="https://kennyballou.com/blog"> UP </a>
 |
 <a accesskey="H" href="https://kennyballou.com/"> HOME </a>
</div><header id="" class="status">
<nav>
  <a href="/about.html">
    <i class="fade fas fa-user-circle"></i>
  </a>
  <a href="https://git.sr.ht/~kennyballou/"
     target="_blank"
     rel="noopener noreferrer">
    <i class="fade fas fa-code-branch fa-1x"></i>
  </a>
  <a href="https://github.com/kennyballou"
     target="_blank"
     rel="noopener noreferrer">
    <i class="fade fab fa-github fa-1x"></i>
  </a>
  <a href="https://bitbucket.org/kballou"
     target="_blank"
     rel="noopener noreferrer">
    <i class="fade fab fa-bitbucket fa-1x"></i>
  </a>
  <a href="https://linkedin.com/in/kennyballou"
     target="_blank"
     rel="noopener noreferrer">
    <i class="fade fab fa-linkedin-in fa-1x"></i>
  </a>
  <a href="/support.html">
    <i class="fade fas fa-heart fa-1x"></i>
  </a>
  <a href="/resume.pdf"
     target="_blank">
    <i class="fade far fa-file-pdf"></i>
  </a>
  <a href="/B74CC4B41148C3DB364BC21182D94B35744E1B34.asc"
     target="_blank">
    <i class="fade fas fa-key"></i>
  </a>
  <a href="/index.xml" rel="alternate"
     type="application/rss+xml">
    <i class="fade fas fa-rss fa-1x"></i>
  </a>
</nav>
</header>
<div id="main">
<h1 class="title">Elixir/Erlang Hot Swapping Code</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1916d6b">Hot Code Swapping: Basics</a>
<ul>
<li><a href="#org7474a29">Example</a></li>
<li><a href="#org78361c9">Example: <code>iex</code></a></li>
</ul>
</li>
<li><a href="#org6815fb9">Relups</a>
<ul>
<li><a href="#orgd5c368f">Erlang Applications</a></li>
<li><a href="#org20dfb92">Erlang Releases</a></li>
<li><a href="#org0f8a5cb">Appups and Relups</a></li>
<li><a href="#generating-releases-and-upgrades-with-elixir">Generating Releases and Upgrades with Elixir</a></li>
</ul>
</li>
<li><a href="#org81af065">Summary</a></li>
</ul>
</div>
</div>
<div class="PREVIEW">
<p>
One of the untold benefits of having a runtime is the ability for that runtime
to enable loading and unloading code while the runtime is active.  Since the
runtime is itself, essentially, a virtual machine with its own operating system
and process scheduling, it has the ability to start and stop, load and unload
processes and code similar to how "real" operating systems do.
</p>

</div>

<div class="embed-video">
<iframe width="560" height="315"
src="https://www.youtube.com/embed/xrIjfIjssLE?rel=0"
frameborder="0" allow="autoplay; encrypted-media"
allowfullscreen></iframe></div>

<blockquote>
<p>
Warning, there be black magic here.
</p>
</blockquote>

<p>
This enables some spectacular power in terms of creating deployments and
rolling out those deployments.  That is, if we can provide a particular
artifact for the runtime to load and replace the running system with, we can
instruct it to upgrade our system(s) <i>without</i> restarting them, without
interrupting our services or affecting users of those systems.  Furthermore, if
we constrain the system and make a few particular assumptions, this can all
happen nearly instantaneously.  For example, Erlang releases happen in seconds
because of the functional approach taken by the language, this compared to
other systems like <a href="https://docker.com">Docker</a> and/or <a href="http://kubernetes.io/">Kubernetes</a> which
may take several minutes or hours to transition a version because there is no
safe assumptions to make about running code.
</p>

<p>
This post will be a small tour through how Elixir and Erlang can perform code
hot swapping, and how this can be useful for deployments.
</p>

<div id="outline-container-org1916d6b" class="outline-2">
<h2 id="org1916d6b">Hot Code Swapping: Basics</h2>
<div class="outline-text-2" id="text-org1916d6b">
<p>
There are several functions defined in the <a href="http://erlang.org/doc/man/sys.html"><code>:sys</code></a> and
<a href="http://erlang.org/doc/man/code.html"><code>:code</code></a> modules that are required for this first example.
Namely, the following functions:
</p>

<ul class="org-ul">
<li><code>:code.load_file/1</code></li>

<li><code>:sys.suspend/1</code></li>

<li><code>:sys.change_code/4</code></li>

<li><code>:sys.resume/1</code></li>
</ul>

<p>
The <code>:sys.suspend/1</code> function takes a single parameter, the Process ID
(PID) of the process to suspend, similarly, <code>:sys.resume</code> also takes a
PID of the process to resume.  The <code>:code.load_file/1</code> function,
unfortunately named, takes a single parameter: the <i>module</i> to load into
memory.  Finally, the <code>:sys.change_code</code> function takes four parameters:
<code>name</code>, <code>module</code>, <code>old_version</code>, and <code>extra</code>.  The <code>name</code> is the PID or
the registered atom of the process.  The <code>extra</code> argument is a reserved
parameter for each process, it's the same <code>extra</code> that will be passed to
the restarted process's <code>code_change/3</code> function.
</p>
</div>

<div id="outline-container-org7474a29" class="outline-3">
<h3 id="org7474a29">Example</h3>
<div class="outline-text-3" id="text-org7474a29">
<p>
Let's assume we have a particularly simple module, say <code>KV</code>, similar to
the following:
</p>

<pre class="example">
defmodule KV do
  use GenServer

  @vsn 0

  def start_link() do
    GenServer.start_link(__MODULE__, [], name: __MODULE__)
  end

  def init(_) do
    {:ok, %{}}
  end

  def get(key, default \\ nil) do
    GenServer.call(__MODULE__, {:get, key, default})
  end

  def put(key, value) do
    GenServer.call(__MODULE__, {:put, key, value})
  end

  def handle_call({:get, key, default}, _caller, state) do
    {:reply, Map.get(state, key, default), state}
  end

  def handle_call({:put, key, value}, _caller, state) do
    {:reply, :ok, Map.put(state, key, value)}
  end

end
</pre>

<p>
Save this into a file, say, <code>kv.ex</code>.  Next we will compile it and load it
into an <code>iex</code> session:
</p>

<pre class="example">
% elixirc kv.ex
% iex
iex&gt; l KV
{:module, KV}
</pre>

<p>
We can start the process and try it out:
</p>

<pre class="example">
iex&gt; KV.start_link
{:ok, #PID&lt;0.84.0&gt;}
iex&gt; KV.get(:a)
nil
iex&gt; KV.put(:a, 42)
:ok
iex&gt; KV.get(:a)
42
</pre>

<p>
Now, let's say we wish to add some logging to the handling of the <code>:get</code>
and <code>:put</code> messages.  We will apply a patch similar to the following:
</p>

<pre class="example">
--- a/kv.ex
+++ b/kv.ex
@@ -1,7 +1,8 @@
 defmodule KV do
+  require Logger
   use GenServer

-  @vsn 0
+  @vsn 1

   def start_link() do
     GenServer.start_link(__MODULE__, [], name: __MODULE__)
@@ -20,10 +21,12 @@ defmodule KV do
   end

   def handle_call({:get, key, default}, _caller, state) do
+    Logger.info("#{__MODULE__}: Handling get request for #{key}")
     {:reply, Map.get(state, key, default), state}
   end

   def handle_call({:put, key, value}, _caller, state) do
+    Logger.info("#{__MODULE__}: Handling put request for #{key}:#{value}")
     {:reply, :ok, Map.put(state, key, value)}
   end
</pre>

<p>
Without closing the current <code>iex</code> session, apply the patch to the file
and compile the module:
</p>

<pre class="example">
% patch kv.ex kv.ex.patch
% elixirc kv.ex
</pre>

<blockquote>
<p>
You may see a warning about redefining an existing module, this
warning can be safely ignored.
</p>
</blockquote>

<p>
Now, in the still open <code>iex</code> session, let's begin the black magic
incantations:
</p>

<pre class="example">
iex&gt; :code.load_file KV
{:module, KV}
iex&gt; :sys.suspend(KV)
:ok
iex&gt; :sys.change_code(KV, KV, 0, nil)
:ok
iex&gt; :sys.resume(KV)
:ok
</pre>

<p>
Now, we should be able to test it again:
</p>

<pre class="example">
iex&gt; KV.get(:a)
21:28:47.989 [info]  Elixir.KV: Handling get request for a
42
iex&gt; KV.put(:b, 2)
21:28:53.729 [info]  Elixir.KV: Handling put request for b:2
:ok
</pre>

<p>
Thus, we are able to hot-swap running code, without stopping, losing
state, or effecting processes waiting for that data!
</p>

<p>
But the above is merely an example of manually invoking the code
reloading API, there are better ways to achieve the same result.
</p>
</div>
</div>

<div id="outline-container-org78361c9" class="outline-3">
<h3 id="org78361c9">Example: <code>iex</code></h3>
<div class="outline-text-3" id="text-org78361c9">
<p>
There are several functions available to us when using <code>iex</code> that
essentially perform the above actions for us:
</p>

<ul class="org-ul">
<li><code>c/1</code>: compile file</li>

<li><code>r/1</code>: (recompile and) reload module</li>
</ul>

<p>
The <code>r/1</code> helper takes an atom of the module to reload, <code>c/1</code> takes a binary of
the path to the module to compile.  Check the
<a href="http://elixir-lang.org/docs/stable/iex/IEx.Helpers.html">documentation</a> for more information.
</p>

<p>
Therefore, using these, we can simplify what we did in the previous example to
simply a call to <code>r/1</code>:
</p>

<pre class="example">
iex&gt; r KV
warning: redefining module KV (current version loaded from Elixir.KV.beam)
  kv.ex:1

{:reloaded, KV, [KV]}
iex&gt; KV.get(:a)

21:52:47.829 [info]  Elixir.KV: Handling get request for a
42
</pre>

<p>
In one function, we have done what previously took four functions.  However,
the story does not end here.  This was only for a single module, one
<code>GenServer</code>.  What about when we want to upgrade more modules, or an entire
application?
</p>

<blockquote>
<p>
Although <code>c/1</code> and <code>r/1</code> are great for development.  They are <i>not</i>
recommended for production use.  Do not depend on them to perform
deployments.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org6815fb9" class="outline-2">
<h2 id="org6815fb9">Relups</h2>
<div class="outline-text-2" id="text-org6815fb9">
<p>
Fortunately, there is another set of tooling that allows us to more
easily deploy releases, and more pointedly, perform upgrades: Relups.
Before we dive straight into relups, let's discuss a few other related
concepts.
</p>
</div>

<div id="outline-container-orgd5c368f" class="outline-3">
<h3 id="orgd5c368f">Erlang Applications</h3>
<div class="outline-text-3" id="text-orgd5c368f">
<p>
As part of Erlang "Applications", there is a related file, the
<a href="http://erlang.org/doc/man/app.html"><code>.app</code></a> file.  This resource file describes the application:
other applications that should be started and other metadata about the
application.  Using Elixir, this file can be found in the
<code>_build/{Mix.env}/lib/{app_name}/ebin/</code> folder.
</p>

<p>
Here's an example <code>.app</code> file from the <a href="https://git.devnulllabs.io/demos/octochat.git">octochat</a> demo
application:
</p>

<pre class="example">
± cat _build/dev/lib/octochat/ebin/octochat.app
{application,octochat,
         [{registered,[]},
          {description,"Demo Application for How Swapping Code"},
          {vsn,"0.3.3"},
          {modules,['Elixir.Octochat','Elixir.Octochat.Acceptor',
                    'Elixir.Octochat.Application','Elixir.Octochat.Echo',
                    'Elixir.Octochat.ServerSupervisor',
                    'Elixir.Octochat.Supervisor']},
          {applications,[kernel,stdlib,elixir,logger]},
          {mod,{'Elixir.Octochat.Application',[]}}]}.
</pre>

<p>
This is a pretty good sized triple (3-tuple).  By the first element of the
triple, we can tell it is an <code>application</code>, the application's name is
<code>octochat</code> given by the second element, and everything in the list that follows
is a keyword list that describes more about the <code>octochat</code>
application.  Notably, we have the usual metadata found in the <code>mix.exs</code> file,
the <code>modules</code> that make up the application, and the other OTP applications this
application requires to run.
</p>
</div>
</div>

<div id="outline-container-org20dfb92" class="outline-3">
<h3 id="org20dfb92">Erlang Releases</h3>
<div class="outline-text-3" id="text-org20dfb92">
<p>
An Erlang "release", similar to Erlang application, is an entire system: the
Erlang VM, the dependent set of applications, and arguments for the Erlang VM.
</p>

<p>
After building a release for the Octochat application with the
<a href="https://github.com/bitwalker/distillery"><code>distillery</code></a> project, we get a <code>.rel</code> file similar to the
following:
</p>

<pre class="example">
± cat rel/octochat/releases/0.3.3/octochat.rel
{release,{"octochat","0.3.3"},
     {erts,"8.1"},
     [{logger,"1.3.4"},
      {compiler,"7.0.2"},
      {elixir,"1.3.4"},
      {stdlib,"3.1"},
      {kernel,"5.1"},
      {octochat,"0.3.3"},
      {iex,"1.3.4"},
      {sasl,"3.0.1"}]}.
</pre>

<p>
This is an Erlang 4-tuple; it's a <code>release</code> of the <code>"0.0.3"</code> version of
<code>octochat</code>.  It will use the <code>"8.1"</code> version of "erts" and it depends on the
list of applications (and their versions) provided in the last element of the
tuple.
</p>
</div>
</div>

<div id="outline-container-org0f8a5cb" class="outline-3">
<h3 id="org0f8a5cb">Appups and Relups</h3>
<div class="outline-text-3" id="text-org0f8a5cb">
<p>
As the naming might suggest, "appups" and "relups" are the "upgrade"
versions of applications and releases, respectively.  Appups describe how
to take a single application and upgrade its modules, specifically, it
will have instructions for upgrading modules that require "extras". or,
if we are upgrading supervisors, for example, the Appup will have the
correct instructions for adding and removing child processes.
</p>

<p>
Before we examine some examples of these files, let's first look at the
type specification for each.
</p>

<p>
Here is the syntax structure for the <code>appup</code> resource file:
</p>

<pre class="example">
{Vsn,
  [{UpFromVsn, Instructions}, ...],
  [{DownToVsn, Instructions}, ...]}.
</pre>

<p>
The first element of the triple is the version we are either upgrading to or
downgrading from.  The second element is a keyword list of upgrade instructions
keyed by the version the application would be coming <i>from</i>.  Similarly, the
third element is a keyword list of downgrade instructions keyed by the version
the application will downgrade <i>to</i>.  For more information about the types
themselves, see the <a href="http://erlang.org/doc/man/appup.html">SASL documentation</a>.
</p>

<p>
Now that we have seen the syntax, let's look at an example of the appup
resource file for the octochat application generated using
<a href="https://github.com/bitwalker/distillery">distillery</a>:
</p>

<pre class="example">
± cat rel/octochat/lib/octochat-0.2.1/ebin/octochat.appup
{"0.2.1",
 [{"0.2.0",[{load_module,'Elixir.Octochat.Echo',[]}]}],
 [{"0.2.0",[{load_module,'Elixir.Octochat.Echo',[]}]}]}.
</pre>

<p>
Comparing this to the syntax structure above, we see that we have a <code>Vsn</code>
element of <code>"0.2.1"</code>, we have a <code>{UpFromVsn, Instructions}</code> pair:
<code>[{"0.2.0",[{load_module,'Elixir.Octochat.Echo',[]}]}]</code>, and we have a single
<code>{DownToVsn, Instructions}</code> pair:
<code>[{"0.2.0",[{load_module,'Elixir.Octochat.Echo',[]}]}]</code>.
</p>

<p>
The instructions themselves tell us what exactly is required to go from one
version to the another.  Specifically, in this example, to upgrade, we need to
"load" the <code>Octochat.Echo</code> module into the VM.  Similarly, the instructions to
downgrade are the same.  For a <a href="http://semver.org">semantically versioned</a>
project, this is an understandably small change.
</p>

<p>
It's worth noting the instructions found in the <code>.appup</code> files are
usually high-level instructions, thus, <code>load_module</code> covers both the
loading of object code into memory and the suspend, replace, resume
process of upgrading applications.
</p>

<p>
Next, let's look at the syntax structure of a <code>relup</code> resource file:
</p>

<pre class="example">
{Vsn,
 [{UpFromVsn, Descr, Instructions}, ...],
 [{DownToVsn, Descr, Instructions}, ...]}.
</pre>

<p>
This should look familiar.  It's essentially the exact same as the
<code>.appup</code> file.  However, there's an extra term, <code>Descr</code>.  The <code>Descr</code>
field can be used as part of the version identification, but is
optional.  Otherwise, the syntax of this file is the same as the
<code>.appup</code>.
</p>

<p>
Now, let's look at an example <code>relup</code> file for the same release of
octochat:
</p>

<pre class="example">
± cat rel/octochat/releases/0.2.1/relup
{"0.2.1",
 [{"0.2.0",[],
   [{load_object_code,{octochat,"0.2.1",['Elixir.Octochat.Echo']}},
    point_of_no_return,
    {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}]}],
 [{"0.2.0",[],
   [{load_object_code,{octochat,"0.2.0",['Elixir.Octochat.Echo']}},
    point_of_no_return,
    {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}]}]}.
</pre>

<p>
This file is a little more dense, but still adheres to the basic triple syntax
we just examined.  Let's take a closer look at the upgrade instructions:
</p>

<pre class="example">
[{load_object_code,{octochat,"0.2.1",['Elixir.Octochat.Echo']}},
 point_of_no_return,
 {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}]
</pre>

<p>
The first instruction,
<code>{load_object_code,{octochat,"0.2.1",['Elixir.Octochat.Echo']}}</code>, tells the
<a href="http://erlang.org/doc/man/release_handler.html">release handler</a> to load into memory the new
version of the "Octochat.Echo" module, specifically the one associated with
version "0.2.1".  But this instruction will not instruct the release handler to
(re)start or replace the existing module yet.  Next, <code>point_of_no_return</code>, tells
the release handler that failure beyond this point is fatal, if the upgrade
fails after this point, the system is restarted from the old release version
(<a href="http://erlang.org/doc/man/appup.html">appup documentation</a>).  The final instruction,
<code>{load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}</code>, tells the release
handler to replace the running version of the module and use the newly loaded
version.
</p>

<p>
For more information regarding <code>burtal_purge</code>, check out the "PrePurge" and
"PostPurge" values in the <a href="http://erlang.org/doc/man/appup.html">appup documentation</a>.
</p>

<p>
Similar to the <code>.appup</code> file, the third element in the triple describes to the
release handler how to downgrade the release as well.  The version numbers in
this case make this a bit more obvious as well, however, the steps are
essentially the same.
</p>
</div>
</div>

<div id="outline-container-org9262994" class="outline-3">
<h3 id="generating-releases-and-upgrades-with-elixir">Generating Releases and Upgrades with Elixir</h3>
<div class="outline-text-3" id="text-generating-releases-and-upgrades-with-elixir">
<p>
Now that we have some basic understanding of releases and upgrades, let's see
how we can generate them with Elixir.  We will generate the releases with the
<a href="https://github.com/bitwalker/distillery">distillery</a> project, however, the commands should also work with
the soon to be deprecated <a href="https://github.com/bitwalker/exrm">exrm</a> project.
</p>

<blockquote>
<p>
This has been written for the <code>0.10.1</code> version of
<a href="https://github.com/bitwalker/distillery">distillery</a>.  This is a
fast moving project that is in beta, be prepared to update as
necessary.
</p>
</blockquote>

<p>
Add the <a href="https://github.com/bitwalker/distillery">distillery</a> application to your <code>deps</code> list:
</p>

<pre class="example">
{:distillery, "~&gt; 0.10"}
</pre>

<p>
Perform the requisite dependency download:
</p>

<pre class="example">
± mix deps.get
</pre>

<p>
Then, to build your first production release, you can use the following:
</p>

<pre class="example">
± MIX_ENV=prod mix release --env prod
</pre>

<blockquote>
<p>
For more information on why you must specify both environments, please read
the <a href="https://hexdocs.pm/distillery/common-issues.html#why-do-i-have-to-set-both-mix_env-and-env">FAQ</a> of distillery.  If the environments match,
there's a small modification to the <code>./rel/config.exs</code> that can be made so
that specifying both is no longer necessary.
</p>
</blockquote>

<p>
After this process is complete, there should be a new folder under the <code>./rel</code>
folder that contains the new release of the project.  Within this directory,
there will be several directories, namely, <code>bin</code>, <code>erts-{version}</code>, <code>lib</code>, and
<code>releases</code>.  The <code>bin</code> directory will contain the top level Erlang entry
scripts, the <code>erts-{version}</code> folder will contain the requisite files for the
Erlang runtime, the <code>lib</code> folder will contain the compiled beam files for the
required applications for the release, and finally, the <code>releases</code> folder will
contain the versions of the releases.  Each folder for each version will have
its own <code>rel</code> file, generated boot scripts, as per the
<a href="http://erlang.org/doc/design_principles/release_structure.html">OTP releases guide</a>, and a tarball of the release
for deployment.
</p>

<p>
Deploying the release is a little out of scope for this post and may be the
subject of another.  For more information about releases, see the
<a href="http://erlang.org/doc/system_principles/create_target.html">System Principles</a> guide.  However, for
Elixir, it may look similar to the following:
</p>

<ul class="org-ul">
<li><p>
Copy the release tarball to the target system:
</p>

<pre class="example">
± scp rel/octochat/releases/0.3.2/octochat.tar.gz target_system:/opt/apps/.
</pre></li>

<li><p>
On the target system, unpack the release:
</p>

<pre class="example">
± ssh target_system
(ts)# cd /opt/apps
(ts)# mkdir -p octochat
(ts)# tar -zxf octochat.tar.gz -C octochat
</pre></li>

<li><p>
Start the system:
</p>

<pre class="example">
(ts)# cd octochat
(ts)# bin/octochat start
</pre></li>
</ul>

<p>
This will bring up the Erlang VM and the application tree on the target system.
</p>

<p>
Next, after making some applications changes and bumping the project version,
we can generate an upgrade release using the following command:
</p>

<pre class="example">
± MIX_ENV=prod mix release --upgrade
</pre>

<blockquote>
<p>
Note, This will <i>also</i> generate a regular release.
</p>
</blockquote>

<p>
Once this process finishes, checking the <code>rel/{app_name}/releases</code> folder,
there should be a new folder for the new version, and a <code>relup</code> file for the
upgrade:
</p>

<pre class="example">
± cat rel/octochat/releases/0.3.3/octochat.rel
{release,{"octochat","0.3.3"},
     {erts,"8.1"},
     [{logger,"1.3.4"},
      {compiler,"7.0.2"},
      {elixir,"1.3.4"},
      {stdlib,"3.1"},
      {kernel,"5.1"},
      {octochat,"0.3.3"},
      {iex,"1.3.4"},
      {sasl,"3.0.1"}]}.

± cat rel/octochat/releases/0.3.3/relup
{"0.3.3",
 [{"0.3.2",[],
   [{load_object_code,{octochat,"0.3.3",['Elixir.Octochat.Echo']}},
    point_of_no_return,
    {suspend,['Elixir.Octochat.Echo']},
    {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}},
    {code_change,up,[{'Elixir.Octochat.Echo',[]}]},
    {resume,['Elixir.Octochat.Echo']}]}],
 [{"0.3.2",[],
   [{load_object_code,{octochat,"0.3.1",['Elixir.Octochat.Echo']}},
    point_of_no_return,
    {suspend,['Elixir.Octochat.Echo']},
    {code_change,down,[{'Elixir.Octochat.Echo',[]}]},
    {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}},
    {resume,['Elixir.Octochat.Echo']}]}]}.
</pre>

<p>
Similarly, to deploy this new upgrade, copy the tarball to the target system
and unpack it into the same directory as before.
</p>

<p>
After it's unpacked, upgrading the release can be done via a stop and start, or
we can issue the <code>upgrade</code> command:
</p>

<pre class="example">
(ts)# bin/octochat stop
(ts)# bin/octochat start
</pre>

<p>
Or:
</p>

<pre class="example">
(ts)# bin/octochat upgrade "0.3.3"
</pre>

<p>
When starting and stopping, the entry point script knows how to select the
"newest" version.
</p>

<p>
When upgrading, it is required to specify the desired version, this is
necessary since the upgrade process may require more than simply jumping to the
"latest" version.
</p>
</div>
</div>
</div>

<div id="outline-container-org81af065" class="outline-2">
<h2 id="org81af065">Summary</h2>
<div class="outline-text-2" id="text-org81af065">
<p>
Release management is a complex topic, upgrading without restarting seemingly
even more so.  However, the process <i>can</i> be understood, and knowing how the
process works will allow us to make more informed decisions regarding when to
use it.
</p>

<p>
The tooling for performing hot upgrades has been around for a while, and while
the tooling for Elixir is getting closer, we are not quite ready for prime
time.  But it won't remain this way for long.  Soon, it will be common place
for Elixir applications to be just as manageable as the Erlang counterparts.
</p>
</div>
</div>
</div>
<footer id="" class="status">
<footer>
  <p>&copy; 2014-2023 Kenny Ballou.
    <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Some rights
      reserved.</a></p>
  <p>Powered by <a href="https://gnu.org">GNU/Linux</a></p>
</footer>
</footer>
</body>
</html>
